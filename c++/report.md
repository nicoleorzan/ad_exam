##Binary Search Tree report

The aim of this exam was to implement and test a Binary Search Tree in c++ language.
We organized our project dividing it into thwo main parts:the first part concerns the code implementation; we divided the code into an header btree.h, located inside the "include" folder, in which are defined and implemented the classes BTree, BNode and the Iterators and their functions are defined, and a source file btree.cc, located inside the "src" folder, in which the longer functions are implemented.
The second part concerns the code testing, for which we wrote the file main_var.cc where we checked the correcness of the code using different vaiable types, and the files contained inside the "test: folder, where we took tests to ckeck the behavior of the time for the lokup inside the tree.

#The Code
The Binary Search Trees are generated by the BTree class, which is templated on the type of the keys and the values of the nodes, and on the comparison operator between keys. The primary componenet of the tree is the class BNode, defined inside the BTree class, in such a way that it is visible only to it.
Let's first of all discuss the BNode composition:

#BNode components
All the BNode components are templated on the key type, the value type and the operator, as the BTree. A BNode contains:
- an std::pair made by a key and an associated value;
- two BNode unique pointers to the left and right childs;
- a raw pointer to the next node, which is the one with the in order following value; this member is mostly used by the Iterator (...keep on reading to know more!).
By doing this the only definition needed inside the tree is the unique pointer to the first node inserted into the tree, which is called root node.
We defined two different constructors for the BNode class:
- one which requires only the insertion of an std::pair, made only for the root node;
- one which requires a std::pair and a pointer to the next node, needed to construct all following nodes.
The BNode class contains some private methods which are mostly recursive and are used by other BTree public methods. There are no BNode public methods.

#BTree components
Inside the BTree class we defined and implemented the following data members:
- a BNode unique pointer to the root, as already said;
- an instance of the comparison operator;
- a BTree default empty constructor;
- a BTree constructor which needs an std::pair (to set the root node) and a comparions operator, which for the moment is set to default;
- the BTree destructor; which will be developed inside the source file.
The Btree is provided with a copy semantic, which copies the tree using a BNode recursive function and construcs a new tree, and a BTree move constructor and move assignment, which instead use the built-in std::move.
Inside the header we defined also a struct comparison, which represent the comparison operator between two templated keys; there are then different public BTree functions which are then developed inside the source file.

#Iterators
Inside the BTree we defined the classes Iterator and ConstIterator; these objects contain a pointer to BNode and thanks to their methods they can be used to access every element of the tree in order, starting from the leftmost node (which is the one with the smaller key value) and incrementing until the end of the tree (the bigger key value).
Thanks to the Iterators, the tree class is provided with the functions begin() and end(), which return respectively an Iterator to the leftmost node of the tree and an Itereator set to nullptr; we wrote also three custom boolean operators to compare the nodes(using != == and is_nullptr operators) and an operator "++" which allows to get the next node respect to the one we are pointing to. Iterating from begin to end, and using the custom "++" operator, the print function is albe to print out in order all the keys and values of the nodes.
We wrote then a "find" function which, given a key, returns an Iterator to the node with the given key.
The class ConstIterators inherites from the Iterator one, and is provided with the constant functions cbegin(), cend() and cfind().

The BTree functions developed inside the source file are the following:
- measure_depth(): a function which returns the total depth of the tree;
- insert(std::pair<TK,TV>): a function used to insert a new BNode given a new pair key-value type, which recursively calls a BNode insert function;
- clear(): function which deletes the tree, and which is called also by the tree destructor;
- print(): a function which prints out the tree following the order of the keys (using the ConstIterator);
- balance(): a function which balances the tree. We decided to implement it storing the tree pairs key-value in a vector traversing the tree in order, then emptying the tree using clear(), and then refilling it in a recursive way using a BTree private function built_tree(). The built_tree is a recursive function which needs a vector, a starting and an ending point, and searches everytime the middle point of the given vector to insert it inside the tree.
- is_balanced(): a functions which checks if the tree is balanced computing recursively the difference of the sub-trees depth.
- erase(TK k): a function which deletes only the node with the given key.

The code we wrote is documented with doxygen, through the makefile you can easily obtain a latex and an html dovumentation for all the classes and methods implemented.

#Run and test the Code
To test the correctness of the implemented code, first of all we wrote a file main_test.cc, to check the implemented functions using various types for keys and values. Inside the file you can find some void functions which are made to check:
- the constructor, destructor and print functions of the tree;
- the copy-move sematics;
- the find function;
- the balance function;
- the erase function;
This file must be compiled with the compiler option -D DEBUG, that prints on the console some lines which allows to understand what is going on under the hood!

In the folder "test", you can find the files we used to check the trend of the time spent by the code to find a key inside the tree before and after using the balance function on it. 
We know that in the worst case we expect that the algorithm to find a key has a time complexity of O(N), while after the balance of the tree we expact a trend like O(log N), where N is the tree size. To perform the test we compiled the code with the -O0 option to avoid the insertion of any compiler optimization.
At the beginning we performed some tests on our laptops, but to be able to use trees of really big sizes we decided to ask for the help of OpenMP, parallelizing our code and running it on Ulysses cluster.
Using OpenMP we created different threads (generally 20, as Ulysses' cores) and we made each one of them search for the maximum time spent rfor the lookup inside the tree; then we used those values to obtain a mean lookup time. Since we had really an high variance of the values we decided to run this code more times to compute a mean on more values.
We actually noticed that the behavoir of the timings is better after using the balance function rather then before.



